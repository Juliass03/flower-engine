#version 460

#define TAA_MODE 0

struct TAAPushConstant
{
    float cameraStopFactor;
};

layout(push_constant) uniform constants{   
   TAAPushConstant pushConstants;
};

#include "../../glsl/common.glsl"
#include "../../glsl/common_framedata.glsl"

layout (set = 1, binding = 0, rgba16f) uniform image2D outHdrColor;
layout (set = 1, binding = 1) uniform sampler2D inDepth;  
layout (set = 1, binding = 2) uniform sampler2D inHistory; 
layout (set = 1, binding = 3) uniform sampler2D inVelocity;
layout (set = 1, binding = 4) uniform sampler2D inHdrColor;
layout (set = 1, binding = 5) uniform sampler2D inGbufferNormal;

#define GROUP_SIZE  8
#define TILE_DIM    (2 * RADIUS + GROUP_SIZE)
#define RADIUS      1
#define FLT_MIN     0.00000001f
#define FLT_EPS     0.00000001f
#define FLT_MAX_16  65500.0f
const float g_taa_blend_min = 0.0f;
const float g_taa_blend_max = 0.4f;

shared vec3 Tile[TILE_DIM * TILE_DIM];
layout (local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = 1) in;

vec3 getWorldNormal(vec2 uv)
{
    vec4 packGbufferNormalRoughness = texture(inGbufferNormal,uv);
    return unpackGbufferNormal(normalize(packGbufferNormalRoughness.xyz));
}

vec3 Reinhard(vec3 hdr)
{
    return hdr / (hdr + 1.0f);
}

vec3 ReinhardInverse(vec3 sdr)
{
    return 1.0f * sdr / (1.0f - sdr);
}

float luminance(vec3 color)
{
    return max(dot(color, vec3(0.299f, 0.587f, 0.114f)), 0.0001f);
}

vec3 sampleHistoryCatmullRom(in vec2 uv, in vec2 texelSize)
{
    vec2 samplePos = uv / texelSize;
    vec2 texPos1 = floor(samplePos - 0.5f) + 0.5f;
    vec2 f = samplePos - texPos1;
    vec2 w0 = f * (-0.5f + f * (1.0f - 0.5f * f));
    vec2 w1 = 1.0f + f * f * (-2.5f + 1.5f * f);
    vec2 w2 = f * (0.5f + f * (2.0f - 1.5f * f));
    vec2 w3 = f * f * (-0.5f + 0.5f * f);
    vec2 w12 = w1 + w2;
    vec2 offset12 = w2 / (w1 + w2);
    vec2 texPos0 = texPos1 - 1.0f;
    vec2 texPos3 = texPos1 + 2.0f;
    vec2 texPos12 = texPos1 + offset12;
    texPos0 *= texelSize;
    texPos3 *= texelSize;
    texPos12 *= texelSize;
    vec3 result = vec3(0.0f, 0.0f, 0.0f);
    result += texture(inHistory, vec2(texPos0.x, texPos0.y)).xyz * w0.x * w0.y;
    result += texture(inHistory, vec2(texPos12.x, texPos0.y)).xyz * w12.x * w0.y;
    result += texture(inHistory, vec2(texPos3.x, texPos0.y)).xyz * w3.x * w0.y;
    result += texture(inHistory, vec2(texPos0.x, texPos12.y)).xyz * w0.x * w12.y;
    result += texture(inHistory, vec2(texPos12.x, texPos12.y)).xyz * w12.x * w12.y;
    result += texture(inHistory, vec2(texPos3.x, texPos12.y)).xyz * w3.x * w12.y;
    result += texture(inHistory, vec2(texPos0.x, texPos3.y)).xyz * w0.x * w3.y;
    result += texture(inHistory, vec2(texPos12.x, texPos3.y)).xyz * w12.x * w3.y;
    result += texture(inHistory, vec2(texPos3.x, texPos3.y)).xyz * w3.x * w3.y;
    return max(result, 0.0f);
}

vec3 Tap(in vec2 pos, vec2 texelSize)
{
    return Tile[int(pos.x) + TILE_DIM * int(pos.y)];
}

float getLinearDepth(vec2 uv)
{
    float deviceZ = texture(inDepth,uv).r;

    float near = frameData.camInfo.z;
    float far = frameData.camInfo.w;

    float z_b = deviceZ;
    float z_n = 2.0f * z_b - 1.0f;
    return 2.0f * far * near / (near + far - z_n * (near - far));
}

float getLinearDepthHistory(vec2 uv)
{
    return texture(inHistory,uv).w;
}

vec2 getClosestVelocity(in vec2 uv, in vec2 texelSize, out bool isSkyPixel)
{
    vec2 velocity;
    float closestDepth = 0.0f;
    for (int y = -1; y <= 1; ++y)
    {
        for (int x = -1; x <= 1; ++x)
        {
            const vec2 st = uv + vec2(x, y) * texelSize;
            const float depth = texture(inDepth,st).r;
            if (depth >= closestDepth) // now always reverse z
            {
                velocity = texture(inVelocity, st).xy;
                closestDepth = depth;
            }
        }
    }
    isSkyPixel = (closestDepth <= 1e-6f);
    return velocity;
}

vec3 sampleHistory(vec2 uv,vec2 inTexelSize)
{
    return sampleHistoryCatmullRom(uv,inTexelSize);
}

vec3 sampleCurrent(vec2 uv)
{
    return texture(inHdrColor, uv).rgb;
}

vec3 RGBToYCoCg(in vec3 rgb)
{
    return vec3(
        0.25f * rgb.r + 0.5f * rgb.g + 0.25f * rgb.b,
        0.5f * rgb.r - 0.5f * rgb.b,
        -0.25f * rgb.r + 0.5f * rgb.g - 0.25f * rgb.b);
}

vec3 YCoCgToRGB(in vec3 yCoCg)
{
    return vec3(
        yCoCg.x + yCoCg.y - yCoCg.z,
        yCoCg.x + yCoCg.z,
        yCoCg.x - yCoCg.y - yCoCg.z);
}

vec2 gatherDepthMinMax(vec2 uv)
{
    vec4 gatherDepth = textureGather(inDepth, uv, 0);

    float minD = min(min(min(gatherDepth.x,gatherDepth.y),gatherDepth.z),gatherDepth.w);
    float maxD = max(max(max(gatherDepth.x,gatherDepth.y),gatherDepth.z),gatherDepth.w);

    return vec2(minD,maxD);
}

bool edgeDepth(vec2 uv, vec2 texelSize)
{
    vec2 minMax0 = gatherDepthMinMax(uv);

    float diff = minMax0.y - minMax0.x;
    const float adopt = 0.0001f;
    return diff > adopt;
}

void main() 
{
    uvec2 pos = gl_GlobalInvocationID.xy;
    ivec2 dims = textureSize(inHdrColor, 0).xy;
    const vec2 texelSize = 1.0f / vec2(dims.xy);
    vec2 uv = (vec2(pos) + vec2(0.5)) * texelSize; 

    const vec2 tilePos = gl_LocalInvocationID.xy + RADIUS + 0.5f;

    // Populate local memory
    if (gl_LocalInvocationIndex < TILE_DIM * TILE_DIM / 4)
    {
        const ivec2 anchor = ivec2(gl_WorkGroupID.xy) * GROUP_SIZE - RADIUS;

        const ivec2 coord1 = anchor + 
            ivec2( gl_LocalInvocationIndex % TILE_DIM, gl_LocalInvocationIndex / TILE_DIM);
        const ivec2 coord2 = anchor + 
            ivec2((gl_LocalInvocationIndex + TILE_DIM * TILE_DIM / 4) % TILE_DIM, (gl_LocalInvocationIndex + TILE_DIM * TILE_DIM / 4) / TILE_DIM);
        const ivec2 coord3 = anchor + 
            ivec2((gl_LocalInvocationIndex + TILE_DIM * TILE_DIM / 2) % TILE_DIM, (gl_LocalInvocationIndex + TILE_DIM * TILE_DIM / 2) / TILE_DIM);
        const ivec2 coord4 = anchor + 
            ivec2((gl_LocalInvocationIndex + TILE_DIM * TILE_DIM * 3 / 4) % TILE_DIM, (gl_LocalInvocationIndex + TILE_DIM * TILE_DIM * 3 / 4) / TILE_DIM);

        const vec2 uv1 = (coord1 + 0.5f) * texelSize;
        const vec2 uv2 = (coord2 + 0.5f) * texelSize;
        const vec2 uv3 = (coord3 + 0.5f) * texelSize;
        const vec2 uv4 = (coord4 + 0.5f) * texelSize;

        const vec3 color0 = texture(inHdrColor, uv1).xyz;
        const vec3 color1 = texture(inHdrColor, uv2).xyz;
        const vec3 color2 = texture(inHdrColor, uv3).xyz;
        const vec3 color3 = texture(inHdrColor, uv4).xyz;
       
        Tile[gl_LocalInvocationIndex]                               = RGBToYCoCg(Reinhard(color0));
        Tile[gl_LocalInvocationIndex + TILE_DIM * TILE_DIM / 4]     = RGBToYCoCg(Reinhard(color1));
        Tile[gl_LocalInvocationIndex + TILE_DIM * TILE_DIM / 2]     = RGBToYCoCg(Reinhard(color2));
        Tile[gl_LocalInvocationIndex + TILE_DIM * TILE_DIM * 3 / 4] = RGBToYCoCg(Reinhard(color3));
    }
    groupMemoryBarrier();
    barrier();

    ivec2 ggId = ivec2(gl_GlobalInvocationID.xy);

    if (ggId.x >= dims.x || ggId.y >= dims.y)
    {
        imageStore(outHdrColor, ivec2(gl_GlobalInvocationID.xy), vec4(0.0f,0.0f,0.0f,1.0f));
        return; 
    }

    float wsum = 0.0f;
    vec3 vsum = vec3(0.0f, 0.0f, 0.0f);
    vec3 vsum2 = vec3(0.0f, 0.0f, 0.0f);

    #define BLUR_RADIUS 1
    for (float y = -BLUR_RADIUS; y <= BLUR_RADIUS; ++y)
    {
        for (float x = -BLUR_RADIUS; x <= BLUR_RADIUS; ++x)
        {
            const vec3 neigh = Tap(tilePos + vec2(x, y), texelSize);
            const float w = exp(-3.0f * (x * x + y * y) / ((BLUR_RADIUS + 1.0f) * (BLUR_RADIUS + 1.0f)));
            vsum2 += neigh * neigh * w;
            vsum += neigh * w;
            wsum += w;
        }
    }
        
    // nVidia variance clip.
    const vec3 ex = vsum / wsum;
    const vec3 ex2 = vsum2 / wsum;
    const vec3 dev = sqrt(max(ex2 - ex * ex, 0.0f));

    bool isSkyPixel;
    const vec2 velocity = getClosestVelocity(uv, texelSize, isSkyPixel);

    float boxSize = mix(0.5f, 2.0f, isSkyPixel ? 0.0f : smoothstep(0.02f, 0.0f, length(velocity)));

    vec3 history = RGBToYCoCg(sampleHistory(uv - velocity, texelSize));
    vec3 center = Tap(tilePos, texelSize); 
    

    float lenVelocity = abs(velocity.x) + abs(velocity.y);
    float historyDepth = texture(inHistory,uv).w;

    float centerDepth = getLinearDepth(uv);
    float mixDepth = mix(historyDepth, centerDepth, 1.0f / 16.0f);
    
    const float adoptVelocityDiff = 1e-5f;
    const float adoptDepthDiff = 1e-2f;
    float depthDiffH = abs(historyDepth - mixDepth);

    vec3 nmin = ex - dev * boxSize;
    vec3 nmax = ex + dev * boxSize;
    vec3 clampedHistory = clamp(history, nmin, nmax);

    const bool bStatic = lenVelocity < adoptVelocityDiff && !isSkyPixel && depthDiffH < adoptDepthDiff;

    float blendFactor = 1.0f;
    {   
        // move
        const float threshold   = 0.5f;
        const float base        = 0.5f;
        const float gather      = 0.1666f;

        // subpixel flicker reduce
        float depth             = getLinearDepth(uv);
        float texel_vel_mag     = length(velocity * vec2(dims.xy)) * depth;
        float subpixel_motion   = clamp(threshold / (texel_vel_mag + FLT_MIN), 0.0f, 1.0f);
        blendFactor *= texel_vel_mag * base + subpixel_motion * gather;

        vec3 color_history = history;
        vec3 color_current = center;
        float luminance_history     = luminance(color_history);
        float luminance_current     = luminance(color_current);
        float unbiased_difference   = abs(luminance_current - luminance_history) / ((max(luminance_current, luminance_history) + 0.3));
        blendFactor *= 1.0 - unbiased_difference;
        // Clamp
        blendFactor = clamp(blendFactor, g_taa_blend_min, g_taa_blend_max);
    }

    if(bStatic)
    {
        float cameraStop = pushConstants.cameraStopFactor;
        cameraStop = smoothstep(0.0f,1.0f,cameraStop);
        float MinBlendFactor = max(1.0f / 16.0f * 0.15f, blendFactor * 0.15f);
        blendFactor = mix(blendFactor, MinBlendFactor, cameraStop);
    }
    
    vec3 result = mix(clampedHistory, center, blendFactor);
    result = YCoCgToRGB(result);

    const float MaxHalfFloat = 65504.0f;
    vec4 FinalOutput = min(MaxHalfFloat.xxxx, vec4(result,mixDepth));

    int frameIndexMod16 = int(frameData.frameIndex.x) % 16;

    uvec2 Random = Rand3DPCG16(ivec3(ivec2(gl_GlobalInvocationID.xy), frameIndexMod16)).xy;
	vec2 E = Hammersley16(0, 1, Random);
    vec3 OutputQuantizationError = vec3(0.00098, 0.00098, 0.00098);
    FinalOutput.rgb += FinalOutput.rgb * (E.x * OutputQuantizationError);
    FinalOutput.a = mixDepth;
    
    imageStore(outHdrColor, ivec2(gl_GlobalInvocationID.xy), FinalOutput);
}