#version 460

layout (local_size_x = 256) in;

#include "../../glsl/common.glsl"
#include "../../glsl/common_framedata.glsl"

layout(set = 1, binding = 0) readonly buffer PerObjectBuffer
{
	PerObjectData objects[];
} perObjectBuffer;

layout (set = 2, binding = 0, std430) writeonly buffer IndirectDraws
{
	IndexedIndirectCommand indirectDraws[];
};

layout (set = 3, binding = 0, std430) writeonly buffer IndirectDrawCount
{
	OutIndirectDrawCount indirectDrawCount;
};

struct GPUCullingPushConstants
{
	uint drawCount;

	uint cullIndex; 
		// 0 is gbuffer culling
		// 1 is cascade #0 culling
		// 2 is cascade #1 culling
		// 3 is cascade #2 culling
		// 4 is cascade #3 culling
};	

layout(push_constant) uniform constants{   
   GPUCullingPushConstants cullData;
};

void gbufferVisibileCulling(uint id)
{
	PerObjectData objectData = perObjectBuffer.objects[id];
	bool bVisibile = true;

	vec4  sphereBounds = objectData.sphereBounds;
	vec3  center = sphereBounds.xyz;
	float radius = sphereBounds.w;

	vec4 pos = vec4(center,1.0f); pos = objectData.model * pos; // world space pos

	// Sphere Frustum Culling
	for (int i = 0; i < 6; i++) 
	{
		if (dot(pos, frameData.camFrustumPlanes[i]) + radius < 0.0)
		{
			bVisibile = false;
			break;
		}
	}

	// Sotre in buffer if visible
	if(bVisibile)
	{
		uint index = atomicAdd(indirectDrawCount.outDrawCount, 1);

		indirectDraws[index].indexCount    = objectData.indexCount;
		indirectDraws[index].firstIndex    = objectData.firstIndex;
		indirectDraws[index].vertexOffset  = objectData.vertexOffset;
		indirectDraws[index].firstInstance = objectData.firstInstance;
		indirectDraws[index].instanceCount = 1;

		indirectDraws[index].objectId = id;
		indirectDraws[index].materialId = id;
	}
}


// Cascade 可见性剔除
void cascadeVisibileCulling(uint id,uint cascadeId)
{
	PerObjectData objectData = perObjectBuffer.objects[id];
	bool bVisibile = true;

	vec4  sphereBounds = objectData.sphereBounds;
	float radius = sphereBounds.w;
	vec3 center = sphereBounds.xyz;

	vec4 pos = vec4(center,1.0f); 
	pos = objectData.model * pos; // world space pos

	// TODO: Cascade Culling

	// Sotre in buffer if visible
	if(bVisibile)
	{
		uint index = atomicAdd(indirectDrawCount.outDrawCount, 1);

		indirectDraws[index].indexCount    = objectData.indexCount;
		indirectDraws[index].firstIndex    = objectData.firstIndex;
		indirectDraws[index].vertexOffset  = objectData.vertexOffset;
		indirectDraws[index].firstInstance = objectData.firstInstance;
		indirectDraws[index].instanceCount = 1;

		indirectDraws[index].objectId = id;
		indirectDraws[index].materialId = id;
	}
}

void main()
{
    uint idx = gl_GlobalInvocationID.x + 
               gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;

	if (idx == 0)
	{
		atomicExchange(indirectDrawCount.outDrawCount, 0);
	}

barrier();
    
    if(idx < cullData.drawCount)
	{
		if(cullData.cullIndex == 0) // gbuffer culling
		{
			gbufferVisibileCulling(idx);
		}
		else if(cullData.cullIndex >= 1 && cullData.cullIndex <= 4) // cascade shadow culling
		{
			cascadeVisibileCulling(idx,cullData.cullIndex - 1);
		}
    }
}