#version 460

layout (local_size_x = 256) in;

// set = 0 在common.glsl中使用掉了
#include "../../glsl/common.glsl"

layout(set = 1, binding = 0) readonly buffer PerObjectBuffer
{
	PerObjectData objects[];
} perObjectBuffer;

layout (set = 2, binding = 0, std430) writeonly buffer IndirectDraws
{
	IndexedIndirectCommand gbufferIndirectDraws[];
};

layout (set = 3, binding = 0, std430) writeonly buffer IndirectDrawCount
{
	OutIndirectDrawCount indirectDrawCount;
};

struct GPUCullingPushConstants
{
	uint drawCount;
};	

layout(push_constant) uniform constants{   
   GPUCullingPushConstants cullData;
};

void gbufferVisibileCulling(uint id)
{
	PerObjectData objectData = perObjectBuffer.objects[id];
	bool bVisibile = true;

	vec4  sphereBounds = objectData.sphereBounds;
	vec3  center = sphereBounds.xyz;
	float radius = sphereBounds.w;
	vec4 pos = vec4(center,1.0f);
	pos = objectData.model * pos;

	// Sphere Frustum Culling
	for (int i = 0; i < 6; i++) 
	{
		if (dot(pos, frameData.camFrustumPlanes[i]) + radius < 0.0)
		{
			bVisibile = false;
			break;
		}
	}

	// Sotre in buffer if visible
	if(bVisibile)
	{
		uint index = atomicAdd(indirectDrawCount.outGbufferDrawCount, 1);

		gbufferIndirectDraws[index].indexCount    = objectData.indexCount;
		gbufferIndirectDraws[index].firstIndex    = objectData.firstIndex;
		gbufferIndirectDraws[index].vertexOffset  = objectData.vertexOffset;
		gbufferIndirectDraws[index].firstInstance = objectData.firstInstance;
		gbufferIndirectDraws[index].instanceCount = 1;

		gbufferIndirectDraws[index].objectId = id;
		gbufferIndirectDraws[index].materialId = id;
	}
}

void main()
{
    uint idx = gl_GlobalInvocationID.x + 
               gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;

	if (idx == 0)
	{
		atomicExchange(indirectDrawCount.outGbufferDrawCount, 0);
	}

	barrier();
    
    if(idx < cullData.drawCount)
	{
		gbufferVisibileCulling(idx);
    }
}