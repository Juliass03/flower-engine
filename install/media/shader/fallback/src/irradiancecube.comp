#version 460
#extension GL_EXT_nonuniform_qualifier : require

const vec2 cubemapSize = vec2(128.0, 128.0);
const float PI = 3.14159265359;
const float INV_PI = 1.0 / PI;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout (set = 0, binding = 0, rgba16f) writeonly uniform imageCube irradianceMap;
layout (set = 1, binding = 0) uniform sampler2D BindlessSampler2D[];

uint ConvolutionSampleCount = 128;
uint ConvolutionMaxSamples = 1024;

uint cubeWidth = 128;
uint cubeHeight = 128;

struct GPUPushConstants
{
	uint envId;
	float exposure;
};	

layout(push_constant) uniform block
{   
   GPUPushConstants constants;
};

vec2 SampleSphericalMap(vec3 v)
{
	const vec2 invAtan = vec2(0.1591, 0.3183);
    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));
    uv *= invAtan;
    uv += 0.5;
    return uv;
}

vec3 sampleEnvColor(vec3 uv,float lod)
{
	vec3 hdrColor = textureLod(BindlessSampler2D[nonuniformEXT(constants.envId)],SampleSphericalMap(uv),lod).rgb;
	return vec3(1.0) - exp(-hdrColor * constants.exposure);
}

vec3 cubeCoordToWorld(ivec3 cubeCoord, vec2 cubemapSize)
{
	vec2 texCoord = vec2(cubeCoord.xy) / cubemapSize;
	texCoord = texCoord  * 2.0 - 1.0; // -1..1
	switch(cubeCoord.z)
	{
		case 0: return vec3( 1.0, -texCoord.yx);               // +X
		case 1: return vec3(-1.0, -texCoord.y, texCoord.x);    // -X
		case 2: return vec3( texCoord.x,   1.0,  texCoord.y);  // +Y
		case 3: return vec3( texCoord.x,  -1.0, -texCoord.y);  // -Y
		case 4: return vec3( texCoord.x,  -texCoord.y, 1.0);   // +Z
		case 5: return vec3(-texCoord.xy, -1.0);               // -Z
	}
	return vec3(0.0);
}

ivec3 texCoordToCube(vec3 texCoord, vec2 cubemapSize)
{
	vec3 abst = abs(texCoord);
	texCoord /= max(abst.z, max(abst.x, abst.y));

	float cubeFace;
	vec2 uvCoord;
	if (abst.x > abst.y && abst.x > abst.z) 
	{
		// x major
		float negx = step(texCoord.x, 0.0);
		uvCoord = mix(-texCoord.zy, vec2(texCoord.z, -texCoord.y), negx);
		cubeFace = negx;
	} 
	else if (abst.y > abst.z) 
	{
		// y major
		float negy = step(texCoord.y, 0.0);
		uvCoord = mix(texCoord.xz, vec2(texCoord.x, -texCoord.z), negy);
		cubeFace = 2.0 + negy;
	} 
	else 
	{
		// z major
		float negz = step(texCoord.z, 0.0);
		uvCoord = mix(vec2(texCoord.x, -texCoord.y), -texCoord.xy, negz);
		cubeFace = 4.0 + negz;
	}
	uvCoord = (uvCoord + 1.0) * 0.5; // 0..1
	uvCoord = uvCoord * cubemapSize;
	uvCoord = clamp(uvCoord, vec2(0.0), cubemapSize - vec2(1.0));

	return ivec3(ivec2(uvCoord), int(cubeFace));
}

vec2 Hammersley(uint i, uint N) 
{
	// Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
	uint bits = (i << 16u) | (i >> 16u);
	bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
	bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
	bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
	bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
	float rdi = float(bits) * 2.3283064365386963e-10;
	return vec2(float(i) /float(N), rdi);
}

vec3 importanceSampleDiffuse(vec2 Xi, vec3 N )
{
    float CosTheta = 1.0 - Xi.y;
    float SinTheta = sqrt(1.0-CosTheta*CosTheta);
    float Phi = 2*PI*Xi.x;

    vec3 H;
    H.x = SinTheta * cos( Phi );
    H.y = SinTheta * sin( Phi );
    H.z = CosTheta;

    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);
    vec3 TangentX = normalize( cross( UpVector, N ) );
    vec3 TangentY = cross( N, TangentX );

    return TangentX * H.x + TangentY * H.y + N * H.z;
}

vec4 sumDiffuse(vec3 diffuseSample, float NoV, vec4 result)
{
    result.xyz += diffuseSample;
    result.w ++;
    return result;
}

vec3 ImportanceSample (vec3 N)
{
    vec3 V = N;
    vec4 result = vec4(0,0,0,0);
    uint SampleStep = ConvolutionMaxSamples / ConvolutionSampleCount;
    uint sampleId = 0;

    for(uint i = 0; i < ConvolutionSampleCount; i++ )
    {
        vec2 Xi = Hammersley(sampleId, ConvolutionMaxSamples);
        vec3 H = importanceSampleDiffuse( Xi, N);
        vec3 L = normalize(2 * dot( V, H ) * H - V);

        float NoL = clamp(dot( N, L ), 0, 1.0f);
        if (NoL > 0.0)
        {
            float pdf = max(0.0, dot(N, L) * INV_PI);
			
            float solidAngleTexel = 4 * PI / (6 * cubeWidth * cubeWidth);
            float solidAngleSample = 1.0 / (float(ConvolutionSampleCount) * pdf);
            float lod = 0.5 * log2(solidAngleSample / solidAngleTexel);

			vec3 diffuseSample = sampleEnvColor(H,lod);
            result = sumDiffuse(diffuseSample, NoL, result);
        }
        sampleId += SampleStep;
   }

   if (result.w == 0)
   {
	   return result.xyz;
   }
   else   
   {
	   return (result.xyz / result.w);
   }
}

void main()
{		
	ivec3 cubeCoord = ivec3(gl_GlobalInvocationID);
    vec3 worldPos = cubeCoordToWorld(cubeCoord, cubemapSize);
    vec3 N = normalize(worldPos);
	vec3 R = N;
    vec4 sampledColor = vec4(0,0,0,1);
	vec3 importanceSampled = ImportanceSample(R);
	sampledColor.xyz = importanceSampled.xyz;
	imageStore(irradianceMap, cubeCoord, sampledColor);
}