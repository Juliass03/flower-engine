#version 460
#extension GL_EXT_nonuniform_qualifier : require
#include "../../glsl/common.glsl"
#include "../../glsl/common_framedata.glsl"
#define TAA_MODE 0

layout (set = 1, binding = 0,rg16f) uniform writeonly image2D hdrImage;
layout (set = 1, binding = 1,rg16f) uniform writeonly image2D historyImage;
layout (set = 1, binding = 2,rg16f) uniform readonly image2D inTAAImage;

float luminance(vec3 color)
{
    return max(dot(color, vec3(0.299f, 0.587f, 0.114f)), 0.0001f);
}

vec3 restrictTonemapperInverse(vec3 color)
{
	return color / (1 - color.r);
}

const float KarisToneMapAlpha = 0.5f;
vec3 KarisToneMap(vec3 color)
{
	float luma = luminance(color);
    const float alpha = KarisToneMapAlpha;
	if (luma <= alpha)
	{
		return color;
	}
	else
	{
		return color * (alpha * alpha - luma) / (luma * (2 * alpha - 1 - luma));
	}
}

vec3 KarisToneMapInverse(vec3 color)
{
	float luma = luminance(color);
	if (luma <= KarisToneMapAlpha)
	{
		return color;
	}
	else
	{
		return color * (KarisToneMapAlpha * KarisToneMapAlpha - (2 * KarisToneMapAlpha - 1) * luma) / (luma * (1 - luma));
	}
}

vec3 RGBToYCoCg(in vec3 rgb)
{
    return vec3(
        0.25f * rgb.r + 0.5f * rgb.g + 0.25f * rgb.b,
        0.5f * rgb.r - 0.5f * rgb.b,
        -0.25f * rgb.r + 0.5f * rgb.g - 0.25f * rgb.b);
}

vec3 YCoCgToRGB(in vec3 yCoCg)
{
    return vec3(
        yCoCg.x + yCoCg.y - yCoCg.z,
        yCoCg.x + yCoCg.z,
        yCoCg.x - yCoCg.y - yCoCg.z);
}

vec3 ApplySharpening(in vec3 center, in vec3 top, in vec3 left, in vec3 right, in vec3 bottom)
{
    vec3 result = RGBToYCoCg(center);
    float unsharpenMask = 4.0f * result.x;
    unsharpenMask -= RGBToYCoCg(top).x;
    unsharpenMask -= RGBToYCoCg(bottom).x;
    unsharpenMask -= RGBToYCoCg(left).x;
    unsharpenMask -= RGBToYCoCg(right).x;
    result.x = min(result.x + 0.25f * unsharpenMask, 1.1f * result.x);
    return YCoCgToRGB(result);
}

vec3 ReinhardInverse(in vec3 sdr)
{
    return sdr / max(1.0f - sdr, 1e-5f);
}

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    const vec4 colorIn = imageLoad(inTAAImage,ivec2(gl_GlobalInvocationID.xy)).xyzw;
    const vec3 center = colorIn.xyz;
    imageStore(historyImage, ivec2(gl_GlobalInvocationID.xy), colorIn);

#if TAA_MODE == 0
    const vec3 top    = imageLoad(inTAAImage,ivec2(gl_GlobalInvocationID.xy + uvec2( 0,  1))).xyz;
    const vec3 left   = imageLoad(inTAAImage,ivec2(gl_GlobalInvocationID.xy + uvec2( 1,  0))).xyz;
    const vec3 right  = imageLoad(inTAAImage,ivec2(gl_GlobalInvocationID.xy + uvec2(-1,  0))).xyz;
    const vec3 bottom = imageLoad(inTAAImage,ivec2(gl_GlobalInvocationID.xy + uvec2( 0, -1))).xyz;
    const vec3 color = ApplySharpening(center, top, left, right, bottom);
    imageStore(hdrImage, ivec2(gl_GlobalInvocationID.xy), vec4(ReinhardInverse(color),1.0f));
    // imageStore(hdrImage, ivec2(gl_GlobalInvocationID.xy), vec4(restrictTonemapperInverse(color),1.0f));
    // imageStore(hdrImage, ivec2(gl_GlobalInvocationID.xy), vec4(KarisToneMapInverse(color),1.0f));
#else
    imageStore(hdrImage, ivec2(gl_GlobalInvocationID.xy), vec4(center,1.0f));
#endif
}
